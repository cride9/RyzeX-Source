#include "exploits.h"
#include "../../Hooks/hooks.h"

#include "../../SDK/InputSystem.h"
#include "../Networking/networking.h"
#include "../../Interface/Classes/CCSGameRulesProxy.h"
#include "antiaim.h"

void exploits::OnCLMove( float flSamples, bool bFinalTick ) {

	static auto original = detour::clMove.GetOriginal<decltype(&h::hkClMove)>();

	// get original function
	static CConVar* maxusercmdprocess = i::ConVar->FindVar(XorStr("sv_maxusrcmdprocessticks"));

	if (i::ClientState->iSignonState != SIGNONSTATE_FULL || i::ClientState->nChokedCommands >= maxusercmdprocess->GetInt() - 1)
		return original(flSamples, bFinalTick);

	if (!cfg::rage::bDoubletap && !cfg::rage::bHideshot)
		return original(flSamples, bFinalTick);

	if (!IPT::HandleInput(cfg::rage::iDoubletapKey) && iShiftAmount == 0 && !IPT::HandleInput(cfg::rage::iHideShotKey))
		return original(flSamples, bFinalTick);

	int iNextCommandNumber = i::ClientState->iLastOutgoingCommand + i::ClientState->nChokedCommands + 1;
	if (bShouldRecharge && iTicksToStore < min(iRechargeAmount, maxusercmdprocess->GetInt() - 1))
	{
		bIsCurrentlyCharging = true;
		if (g::bSendPacket) *g::bSendPacket = true;

		iTicksToStore++;
		return;
	}
	else if (bIsCurrentlyCharging) {

		original(flSamples, bFinalTick);
		bIsCurrentlyCharging = false;
		bCharged = true;
		return;
	}

	original(flSamples, bFinalTick);

	bIsShiftingTicks = true;
	{
		for (iShiftAmount = min(iTicksToStore, iShiftAmount); iShiftAmount > 0; iShiftAmount--, iTicksToStore--) {

			original(flSamples, bFinalTick);
			bCharged = false;
		}
	}
	bIsShiftingTicks = false;
}

bool exploits::CanDoubleTap( CBaseEntity* pLocal )
{
	if ( !pLocal || !pLocal->GetWeapon( ) )
		return false;
	
	CCSWeaponInfo* pWeaponData = i::WeaponSystem->GetWpnData( pLocal->GetWeapon( )->GetItemDefinitionIndex( ) );
	if ( !pWeaponData || pLocal->GetWeapon( )->GetItemDefinitionIndex( ) == WEAPON_REVOLVER || pLocal->GetWeapon( )->GetItemDefinitionIndex( ) == WEAPON_C4 || pWeaponData->nWeaponType == WEAPONTYPE_GRENADE || !cfg::rage::bEnable || /*!C::Get<bool>( Vars.bRageDoubletap ) || !IPT::HandleInput( C::Get<int>( Vars.iRageDoubletapkey ) ) ||*/ cfg::antiaim::bFakeDuck && IPT::HandleInput( cfg::antiaim::iFakeDuckKey ) )
		return false;
	
	return true;
}

void exploits::HandleHideShots(bool& bSendPacket, CUserCmd* pCmd) {

	if (cfg::rage::bDoubletap && IPT::HandleInput(cfg::rage::iDoubletapKey))
		return;

	if (g::pLocal == nullptr || !g::pLocal->IsAlive() || !i::EngineClient->IsInGame() || !cfg::rage::bHideshot)
		return;

	if (!CanDoubleTap(g::pLocal))
		return;

	static bool bRecharge = false;

	bDoubleTapEnabled = true;

	// Check if DT key is enabled.
	if (!IPT::HandleInput(cfg::rage::iHideShotKey) && iShiftAmount == 0)
	{
		// Reset variables if not
		bDoubleTapEnabled = false;
		iTicksToStore = 0;
		iRechargeAmount = 0;
		iShiftAmount = 0;
		bRecharge = true;
		iHideShiftAmount = 0;
		return;
	}

	// Get our current weapon
	CBaseCombatWeapon* pWeapon = g::pLocal->GetWeapon();

	// Create local variables
	static int iMaxShiftAmmount = 6;
	if (iTicksToStore < iMaxShiftAmmount && bRecharge) {
		bShouldRecharge = true;
		iRechargeAmount = iMaxShiftAmmount + 1;
		bRecharge = false;
		iHideShiftAmount = 0;
	}

	bool bAbleToFire = g::pLocal->CanShoot(pWeapon);

	if (bAbleToFire)
	{
		if (!pWeapon->IsKnife() && !pWeapon->IsGrenade()) {

			if (pCmd->iButtons & IN_ATTACK) {

				iHideShiftAmount = iMaxShiftAmmount;

				const int iFirstTick = prediction.AdjustPlayerTimeBase(-iHideShiftAmount);
				const int iSecondTick = prediction.AdjustPlayerTimeBase(1);

				prediction.SetTickbase(pCmd->iCommandNumber + 1, iFirstTick);
				prediction.SetTickbase(pCmd->iCommandNumber + 2, iSecondTick);

				exploits::bForcePacket = true;
			}
		}
		return;
	}
}

void exploits::HandleDoubleTap( bool& bSendPacket, CUserCmd* pCmd ) {

	if (cfg::rage::bHideshot && IPT::HandleInput(cfg::rage::iHideShotKey))
		return;

	if ( g::pLocal == nullptr || !g::pLocal->IsAlive( ) || !i::EngineClient->IsInGame( ) || !cfg::rage::bDoubletap || !CanDoubleTap(g::pLocal))
		return;

	TurnedOffShift(pCmd);

	bDoubleTapEnabled = true;

	// Get our current weapon
	CBaseCombatWeapon* pWeapon = g::pLocal->GetWeapon( );
	// Retrieve weapon data
	CCSWeaponInfo* pWeaponData = i::WeaponSystem->GetWpnData( pWeapon->GetItemDefinitionIndex( ) );

	// Disable DT if frozen, fakeducking, revolver etc.
	if ( pWeapon->GetItemDefinitionIndex( ) == WEAPON_REVOLVER || !IPT::HandleInput(cfg::rage::iDoubletapKey) && iShiftAmount == 0)
	{
		// Reset Data
		bDoubleTapEnabled = false;
		iLastShiftTime = 0;
		iTicksToStore = 0;
		iRechargeAmount = 0;
		iShiftAmount = 0;
		return;
	}

	static CConVar* sv_maxusrcmdprocessticks = i::ConVar->FindVar(XorStr("sv_maxusrcmdprocessticks"));

	// Create local variables
	int iMaxShiftAmmount = sv_maxusrcmdprocessticks->GetInt() - 1;
	static int iRechargeDelay = TIME_TO_TICKS( 0.5 );

	if ((*GameRules)->m_bIsValveDS()) 
		iMaxShiftAmmount = min(6, iMaxShiftAmmount);

	// Recharge
	if ( !( pCmd->iButtons & IN_ATTACK ) && iTicksToStore < iMaxShiftAmmount && abs(i::GlobalVars->iTickCount - iLastShiftTime) > iRechargeDelay && 
		(bCanCharge ? pWeapon->GetLastShotTime() < i::GlobalVars->flCurrentTime - 1.0f : false))
	{
		iLastShiftTime = 0;
		bShouldRecharge = true;
		iRechargeAmount = iMaxShiftAmmount + 1;
	}
	else if (iTicksToStore >= iMaxShiftAmmount)
		bShouldRecharge = false;

	if (!( pWeaponData->nWeaponType == WEAPONTYPE_GRENADE ) && pWeapon && pCmd->iButtons & IN_ATTACK && iTicksToStore >= iMaxShiftAmmount && !bShouldRecharge)
	{
		iLastShiftTime = i::GlobalVars->iTickCount;
		iShiftAmount = iMaxShiftAmmount;
		prediction.SetTickbase(pCmd->iCommandNumber + 1, prediction.AdjustPlayerTimeBase(-iMaxShiftAmmount));
		return;
	}
}

void exploits::HandleBreakLagcomp(CUserCmd* pCmd) {

	if (!cfg::antiaim::bBreakLagcompensation || bShouldRecharge || !(cfg::rage::bDoubletap && IPT::HandleInput(cfg::rage::iDoubletapKey)))
		return;

	if (bIsCurrentlyCharging || iTicksToStore == 0)
		return;

	//if (cfg::rage::hideshot && IPT::HandleInput(cfg::rage::hideshotkey))
	//	return;

	iDefensive = 16;
}

void exploits::TurnedOffShift(CUserCmd* pCmd) {

	static bool bBackupState = IPT::HandleInput(cfg::rage::iDoubletapKey);

	if (bBackupState && !IPT::HandleInput(cfg::rage::iDoubletapKey)) {

		iLastShiftTime = i::GlobalVars->iTickCount;
		iShiftAmount = 14;
		prediction.SetTickbase(pCmd->iCommandNumber + 1, prediction.AdjustPlayerTimeBase(-14));
	}
	bBackupState = IPT::HandleInput(cfg::rage::iDoubletapKey);
}